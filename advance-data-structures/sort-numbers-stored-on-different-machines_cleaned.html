<body><div><div class="post" id="post">
							<div class="post-info">			
					<p class="post-title-info">
						</p><h2 class="post-title">Sort numbers stored on different machines</h2>
								
					<p class="clear"></p>				  
				<div class="post-content" id="post-content">
					<p>Given N machines. Each machine contains some numbers in sorted form. But the amount of numbers, each machine has is not fixed. Output the numbers from all the machine in sorted non-decreasing form.<span id="more-24463"></span></p>
<pre>
Example:
       Machine M1 contains 3 numbers: {30, 40, 50}
       Machine M2 contains 2 numbers: {35, 45} 
       Machine M3 contains 5 numbers: {10, 60, 70, 80, 100}
       
       Output: {10, 30, 35, 40, 45, 50, 60, 70, 80, 100}
</pre>
<p>Representation of stream of numbers on each machine is considered as linked list. A Min Heap can be used to print all numbers in sorted order. </p>
<p>Following is the detailed process </p>
<p><strong>1.</strong> Store the head pointers of the linked lists in a minHeap of size N where N is number of machines.</p>
<p><strong>2.</strong> Extract the minimum item from the minHeap. Update the minHeap by replacing the head of the minHeap with the next number from the linked list or by replacing the head of the minHeap with the last number in the minHeap followed by decreasing the size of heap by 1.</p>
<p><strong>3.</strong> Repeat the above step 2 until heap is not empty.</p>
<p>Below is C++ implementation of the above approach. </p>
<pre class="brush: cpp; highlight: [113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150]; title: ; notranslate" title="">
// A program to take numbers from different machines and print them in sorted order
#include &lt;stdio.h&gt;

// A Linked List node
struct ListNode
{
    int data;
    struct ListNode* next;
};

// A Min Heap Node
struct MinHeapNode
{
    ListNode* head;
};

// A Min Heao (Collection of Min Heap nodes)
struct MinHeap
{
    int count;
    int capacity;
    MinHeapNode* array;
};

// A function to create a Min Heap of given capacity
MinHeap* createMinHeap( int capacity )
{
    MinHeap* minHeap = new MinHeap;
    minHeap-&gt;capacity = capacity;
    minHeap-&gt;count = 0;
    minHeap-&gt;array = new MinHeapNode [minHeap-&gt;capacity];
    return minHeap;
}

/* A utility function to insert a new node at the begining
   of linked list */
void push (ListNode** head_ref, int new_data)
{
    /* allocate node */
    ListNode* new_node = new ListNode;

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

// A utility function to swap two min heap nodes. This function
// is needed in minHeapify
void swap( MinHeapNode* a, MinHeapNode* b )
{
    MinHeapNode temp = *a;
    *a = *b;
    *b = temp;
}

// The standard minHeapify function.
void minHeapify( MinHeap* minHeap, int idx )
{
    int left, right, smallest;
    left = 2 * idx + 1;
    right = 2 * idx + 2;
    smallest = idx;

    if ( left &lt; minHeap-&gt;count &amp;&amp;
         minHeap-&gt;array[left].head-&gt;data &lt;
         minHeap-&gt;array[smallest].head-&gt;data
       )
        smallest = left;

    if ( right &lt; minHeap-&gt;count &amp;&amp;
         minHeap-&gt;array[right].head-&gt;data &lt;
         minHeap-&gt;array[smallest].head-&gt;data
       )
        smallest = right;

    if( smallest != idx )
    {
        swap( &amp;minHeap-&gt;array[smallest], &amp;minHeap-&gt;array[idx] );
        minHeapify( minHeap, smallest );
    }
}

// A utility function to check whether a Min Heap is empty or not
int isEmpty( MinHeap* minHeap )
{
    return (minHeap-&gt;count == 0);
}

// A standard function to build a heap
void buildMinHeap( MinHeap* minHeap )
{
    int i, n;
    n = minHeap-&gt;count  - 1;
    for( i = (n - 1) / 2; i &gt;= 0; --i )
        minHeapify( minHeap, i );
}

// This function inserts array elements to heap and then calls
// buildHeap for heap property among nodes
void populateMinHeap( MinHeap* minHeap, ListNode* *array, int n )
{
    for( int i = 0; i &lt; n; ++i )
        minHeap-&gt;array[ minHeap-&gt;count++ ].head = array[i];

    buildMinHeap( minHeap );
}

// Return minimum element from all linked lists
ListNode* extractMin( MinHeap* minHeap )
{
    if( isEmpty( minHeap ) )
         return NULL;

    // The root of heap will have minimum value
    MinHeapNode temp = minHeap-&gt;array[0];

    // Replace root either with next node of the same list.
    if( temp.head-&gt;next )
        minHeap-&gt;array[0].head = temp.head-&gt;next;
    else // If list empty, then reduce heap size
    {
        minHeap-&gt;array[0] = minHeap-&gt;array[ minHeap-&gt;count - 1 ];
        --minHeap-&gt;count;
    }

    minHeapify( minHeap, 0 );
    return temp.head;
}

// The main function that takes an array of lists from N machines
// and generates the sorted output
void externalSort( ListNode *array[], int N )
{
    // Create a min heap of size equal to number of machines
    MinHeap* minHeap = createMinHeap( N );

    // populate first item from all machines
    populateMinHeap( minHeap, array, N );

    while ( !isEmpty( minHeap ) )
    {
        ListNode* temp = extractMin( minHeap );
        printf( "%d ",temp-&gt;data );
    }
}

// Driver program to test above functions
int main()
{
    int N = 3; // Number of machines

    // an array of pointers storing the head nodes of the linked lists
    ListNode *array[N];

    // Create a Linked List 30-&gt;40-&gt;50 for first machine
    array[0] = NULL;
    push (&amp;array[0], 50);
    push (&amp;array[0], 40);
    push (&amp;array[0], 30);

    // Create a Linked List 35-&gt;45 for second machine
    array[1] = NULL;
    push (&amp;array[1], 45);
    push (&amp;array[1], 35);

    // Create Linked List 10-&gt;60-&gt;70-&gt;80 for third machine
    array[2] = NULL;
    push (&amp;array[2], 100);
    push (&amp;array[2], 80);
    push (&amp;array[2], 70);
    push (&amp;array[2], 60);
    push (&amp;array[2], 10);

    // Sort all elements
    externalSort( array, N );

    return 0;
}
</pre>
<p>Output:
</p><pre>10 30 35 40 45 50 60 70 80 100</pre>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
		
&#160;
&#160;







&#160;
&#160;
&#160;
<p>Tags: <a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a>, <a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></p> 






				<h3>Source:</h3><p><a href="http://www.geeksforgeeks.org/sort-numbers-stored-on-different-machines/" rel="tag">http://www.geeksforgeeks.org/sort-numbers-stored-on-different-machines/</a></p></div>		  
			</div> 					
						
        
			</div> 	

</div></body>