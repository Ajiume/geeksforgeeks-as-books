<body><div><div class="post" id="post">
							<div class="post-info">			
					<p class="post-title-info">
						</p><h2 class="post-title">Find the k most frequent words from a file</h2>
								
					<p class="clear"></p>				  
				<div class="post-content" id="post-content">
					<p>Given a book of words. Assume you have enough main memory to accommodate all words. design a data structure to find top K maximum occurring words. The data structure should be dynamic so that new words can be added. <span id="more-24329"></span></p>
<p>A simple solution is to <strong>use Hashing</strong>.  Hash all words one by one in a hash table. If a word is already present, then increment its count. Finally, traverse through the hash table and return the k words with maximum counts.</p>
<p>We can <strong>use Trie and Min Heap</strong> to get the k most frequent words efficiently. The idea is to use Trie for searching existing words adding new words efficiently.  Trie also stores count of occurrences of words. A Min Heap of size k is used to keep track of k most frequent words at any point of time(Use of Min Heap is same as we used it to find k largest elements in <a href="http://www.geeksforgeeks.org/archives/2392">this</a> post).<br>
Trie and Min Heap are linked with each other by storing an additional field in Trie &#8216;indexMinHeap&#8217; and a pointer &#8216;trNode&#8217; in Min Heap. The value of &#8216;indexMinHeap&#8217; is maintained as -1 for the words which are currently not in Min Heap (or currently not among the top k frequent words).  For the words which are present in Min Heap, &#8216;indexMinHeap&#8217; contains, index of the word in Min Heap.   The pointer &#8216;trNode&#8217; in Min Heap points to the leaf node corresponding to the word in Trie.</p>
<p>Following is the complete process to print k most frequent words from a file.</p>
<p>Read all words one by one.  For every word, insert it into Trie. Increase the counter of the word, if already exists.  Now, we need to insert this word in min heap also. For insertion in min heap, 3 cases arise:</p>
<p><strong>1.</strong> The word is already present. We just increase the corresponding frequency value in min heap and call minHeapify() for the index obtained by &#8220;indexMinHeap&#8221; field in Trie. When the min heap nodes are being swapped, we change the corresponding minHeapIndex in the Trie. Remember each node of the min heap is also having pointer to Trie leaf node.</p>
<p><strong>2.</strong> The minHeap is not full. we will insert the new word into min heap &amp; update the root node in the min heap node &amp; min heap index in Trie leaf node. Now, call buildMinHeap().</p>
<p><strong>3.</strong> The min heap is full. Two sub-cases arise.<br>
&#8230;.<strong>3.1</strong>  The frequency of the new word inserted is less than the frequency of the word stored in the head of min heap. Do nothing.</p>
<p>&#8230;.<strong>3.2</strong> The frequency of the new word inserted is greater than the frequency of the word stored in the head of min heap. Replace &amp; update the fields. Make sure to update the corresponding min heap index of the &#8220;word to be replaced&#8221; in Trie with -1 as the word is no longer in min heap.</p>
<p><strong>4.</strong> Finally, Min Heap will have the k most frequent words of all words present in given file.  So we just need to print all words present in Min Heap.</p>
<pre class="brush: cpp; highlight: [214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233]; title: ; notranslate" title="">
// A program to find k most frequent words in a file
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

# define MAX_CHARS 26
# define MAX_WORD_SIZE 30

// A Trie node
struct TrieNode
{
    bool isEnd; // indicates end of word
    unsigned frequency;  // the number of occurrences of a word
    int indexMinHeap; // the index of the word in minHeap
    TrieNode* child[MAX_CHARS]; // represents 26 slots each for 'a' to 'z'.
};

// A Min Heap node
struct MinHeapNode
{
    TrieNode* root; // indicates the leaf node of TRIE
    unsigned frequency; //  number of occurrences
    char* word; // the actual word stored
};

// A Min Heap
struct MinHeap
{
    unsigned capacity; // the total size a min heap
    int count; // indicates the number of slots filled.
    MinHeapNode* array; //  represents the collection of minHeapNodes
};

// A utility function to create a new Trie node
TrieNode* newTrieNode()
{
    // Allocate memory for Trie Node
    TrieNode* trieNode = new TrieNode;

    // Initialize values for new node
    trieNode-&gt;isEnd = 0;
    trieNode-&gt;frequency = 0;
    trieNode-&gt;indexMinHeap = -1;
    for( int i = 0; i &lt; MAX_CHARS; ++i )
        trieNode-&gt;child[i] = NULL;

    return trieNode;
}

// A utility function to create a Min Heap of given capacity
MinHeap* createMinHeap( int capacity )
{
    MinHeap* minHeap = new MinHeap;

    minHeap-&gt;capacity = capacity;
    minHeap-&gt;count  = 0;

    // Allocate memory for array of min heap nodes
    minHeap-&gt;array = new MinHeapNode [ minHeap-&gt;capacity ];

    return minHeap;
}

// A utility function to swap two min heap nodes. This function
// is needed in minHeapify
void swapMinHeapNodes ( MinHeapNode* a, MinHeapNode* b )
{
    MinHeapNode temp = *a;
    *a = *b;
    *b = temp;
}

// This is the standard minHeapify function. It does one thing extra.
// It updates the minHapIndex in Trie when two nodes are swapped in
// in min heap
void minHeapify( MinHeap* minHeap, int idx )
{
    int left, right, smallest;

    left = 2 * idx + 1;
    right = 2 * idx + 2;
    smallest = idx;
    if ( left &lt; minHeap-&gt;count &amp;&amp;
         minHeap-&gt;array[ left ]. frequency &lt;
         minHeap-&gt;array[ smallest ]. frequency
       )
        smallest = left;

    if ( right &lt; minHeap-&gt;count &amp;&amp;
         minHeap-&gt;array[ right ]. frequency &lt;
         minHeap-&gt;array[ smallest ]. frequency
       )
        smallest = right;

    if( smallest != idx )
    {
        // Update the corresponding index in Trie node.
        minHeap-&gt;array[ smallest ]. root-&gt;indexMinHeap = idx;
        minHeap-&gt;array[ idx ]. root-&gt;indexMinHeap = smallest;

        // Swap nodes in min heap
        swapMinHeapNodes (&amp;minHeap-&gt;array[ smallest ], &amp;minHeap-&gt;array[ idx ]);

        minHeapify( minHeap, smallest );
    }
}

// A standard function to build a heap
void buildMinHeap( MinHeap* minHeap )
{
    int n, i;
    n = minHeap-&gt;count - 1;

    for( i = ( n - 1 ) / 2; i &gt;= 0; --i )
        minHeapify( minHeap, i );
}

// Inserts a word to heap, the function handles the 3 cases explained above
void insertInMinHeap( MinHeap* minHeap, TrieNode** root, const char* word )
{
    // Case 1: the word is already present in minHeap
    if( (*root)-&gt;indexMinHeap != -1 )
    {
        ++( minHeap-&gt;array[ (*root)-&gt;indexMinHeap ]. frequency );

        // percolate down
        minHeapify( minHeap, (*root)-&gt;indexMinHeap );
    }

    // Case 2: Word is not present and heap is not full
    else if( minHeap-&gt;count &lt; minHeap-&gt;capacity )
    {
        int count = minHeap-&gt;count;
        minHeap-&gt;array[ count ]. frequency = (*root)-&gt;frequency;
        minHeap-&gt;array[ count ]. word = new char [strlen( word ) + 1];
        strcpy( minHeap-&gt;array[ count ]. word, word );

        minHeap-&gt;array[ count ]. root = *root;
        (*root)-&gt;indexMinHeap = minHeap-&gt;count;

        ++( minHeap-&gt;count );
        buildMinHeap( minHeap );
    }

    // Case 3: Word is not present and heap is full. And frequency of word
    // is more than root. The root is the least frequent word in heap,
    // replace root with new word
    else if ( (*root)-&gt;frequency &gt; minHeap-&gt;array[0]. frequency )
    {

        minHeap-&gt;array[ 0 ]. root-&gt;indexMinHeap = -1;
        minHeap-&gt;array[ 0 ]. root = *root;
        minHeap-&gt;array[ 0 ]. root-&gt;indexMinHeap = 0;
        minHeap-&gt;array[ 0 ]. frequency = (*root)-&gt;frequency;

        // delete previously allocated memoory and
        delete [] minHeap-&gt;array[ 0 ]. word;
        minHeap-&gt;array[ 0 ]. word = new char [strlen( word ) + 1];
        strcpy( minHeap-&gt;array[ 0 ]. word, word );

        minHeapify ( minHeap, 0 );
    }
}

// Inserts a new word to both Trie and Heap
void insertUtil ( TrieNode** root, MinHeap* minHeap,
                        const char* word, const char* dupWord )
{
    // Base Case
    if ( *root == NULL )
        *root = newTrieNode();

    //  There are still more characters in word
    if ( *word != '\0' )
        insertUtil ( &amp;((*root)-&gt;child[ tolower( *word ) - 97 ]),
                         minHeap, word + 1, dupWord );
    else // The complete word is processed
    {
        // word is already present, increase the frequency
        if ( (*root)-&gt;isEnd )
            ++( (*root)-&gt;frequency );
        else
        {
            (*root)-&gt;isEnd = 1;
            (*root)-&gt;frequency = 1;
        }

        // Insert in min heap also
        insertInMinHeap( minHeap, root, dupWord );
    }
}


// add a word to Trie &amp; min heap.  A wrapper over the insertUtil
void insertTrieAndHeap(const char *word, TrieNode** root, MinHeap* minHeap)
{
    insertUtil( root, minHeap, word, word );
}

// A utility function to show results, The min heap
// contains k most frequent words so far, at any time
void displayMinHeap( MinHeap* minHeap )
{
    int i;

    // print top K word with frequency
    for( i = 0; i &lt; minHeap-&gt;count; ++i )
    {
        printf( "%s : %d\n", minHeap-&gt;array[i].word,
                            minHeap-&gt;array[i].frequency );
    }
}

// The main funtion that takes a file as input, add words to heap
// and Trie, finally shows result from heap
void printKMostFreq( FILE* fp, int k )
{
    // Create a Min Heap of Size k
    MinHeap* minHeap = createMinHeap( k );
   
    // Create an empty Trie
    TrieNode* root = NULL;

    // A buffer to store one word at a time
    char buffer[MAX_WORD_SIZE];

    // Read words one by one from file.  Insert the word in Trie and Min Heap
    while( fscanf( fp, "%s", buffer ) != EOF )
        insertTrieAndHeap(buffer, &amp;root, minHeap);

    // The Min Heap will have the k most frequent words, so print Min Heap nodes
    displayMinHeap( minHeap );
}

// Driver program to test above functions
int main()
{
    int k = 5;
    FILE *fp = fopen ("file.txt", "r");
    if (fp == NULL)
        printf ("File doesn't exist ");
    else
        printKMostFreq (fp, k);
    return 0;
}
</pre>
<p>Output:
</p><pre>your : 3
well : 3
and : 4
to : 4
Geeks : 6
</pre>
<p>The above output is for a file with following content.
</p><pre>Welcome to the world of Geeks 
This portal has been created to provide well written well thought and well explained 
solutions for selected questions If you like Geeks for Geeks and would like to contribute 
here is your chance You can write article and mail your article to contribute at 
geeksforgeeks org See your article appearing on the Geeks for Geeks main page and help 
thousands of other Geeks
</pre>
<p><br>
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
		
&#160;
&#160;







&#160;
&#160;
&#160;
<p>Tags: <a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></p> 






				<h3>Source:</h3><p><a href="http://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/" rel="tag">http://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/</a></p></div>		  
			</div> 					
						
        
			</div> 	

</div></body>