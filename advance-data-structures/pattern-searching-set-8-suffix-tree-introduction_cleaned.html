<body><div><h2>Pattern Searching | Set 8 (Suffix Tree Introduction)</h2><div class="post-content" id="post-content">
					<p>Given a text txt[0..n-1] and a pattern pat[0..m-1], write a function search(char pat[], char txt[]) that prints all occurrences of pat[] in txt[]. You may assume that n &gt; m.<span id="more-29117"></span></p>
<p><strong>Preprocess Pattern or Preoprocess Text? </strong><br>
We have discussed the following algorithms in the previous posts:</p>
<p><a href="http://www.geeksforgeeks.org/archives/11902">KMP Algorithm</a><br>
<a href="http://www.geeksforgeeks.org/archives/11937">Rabin Karp Algorithm</a><br>
<a href="http://www.geeksforgeeks.org/archives/18919">Finite Automata based Algorithm</a><br>
<a href="http://www.geeksforgeeks.org/pattern-searching-set-7-boyer-moore-algorithm-bad-character-heuristic/">Boyer Moore Algorithm</a></p>
<p>All of the above algorithms preprocess the pattern to make the pattern searching faster. The best time complexity that we could get by preprocessing pattern is O(n) where n is length of the text. In this post, we will discuss an approach that preprocesses the text. A suffix tree is built of the text. After preprocessing text (building suffix tree of text), we can search any pattern in O(m) time where m is length of the pattern.<br>
Imagine you have stored complete work of <a href="http://en.wikipedia.org/wiki/William_Shakespeare" target="_blank">William Shakespeare</a> and preprocessed it. You can search any string in the complete work in time just proportional to length of the pattern. This is really a great improvement because length of pattern is generally much smaller than text.<br>
Preprocessing of text may become costly if the text changes frequently. It is good for fixed text or less frequently changing text though.</p>
<p><strong>A Suffix Tree for a given text is a compressed trie for all suffixes of the given text</strong>. We have discussed <a href="http://www.geeksforgeeks.org/trie-insert-and-search/" target="_blank">Standard Trie</a>. Let us understand <strong>Compressed Trie</strong> with the following array of words.</p>
<pre>{bear, bell, bid, bull, buy, sell, stock, stop}</pre>
<p>Following is standard trie for the above input set of words.<br>
<a href="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/standardtrie.png"><img class="aligncenter size-full wp-image-29192" title="standardtrie" src="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/standardtrieNew.png" alt="" width="500" height="250"></a></p>
<p>Following is the compressed trie. Compress Trie is obtained from standard trie by joining chains of single nodes. The nodes of a compressed trie can be stored by storing index ranges at the nodes.<br>
<a href="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/Compressed-Trie.png"><img class="aligncenter size-full wp-image-29201" title="Compressed Trie" src="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/CompressedTrieNew.png" alt="" width="450" height="190"></a></p>
<p><strong>How to build a Suffix Tree for a given text?</strong><br>
As discussed above, Suffix Tree is compressed trie of all suffixes, so following are very abstract steps to build a suffix tree from given text.<br>
1) Generate all suffixes of given text.<br>
2) Consider all suffixes as individual words and build a compressed trie.</p>
<p>Let us consider an example text &#8220;banana\0&#8243; where &#8216;\0&#8242; is string termination character. Following are all suffixes of &#8220;banana\0&#8243;</p>
<pre>banana\0
anana\0
nana\0
ana\0
na\0
a\0
\0</pre>
<p>If we consider all of the above suffixes as individual words and build a trie, we get following.<br>
<a href="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/suffixtrie.png"><img class="aligncenter size-full wp-image-29287" title="suffixtrie" src="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/suffixtrie.png" alt="" width="500" height="275"></a></p>
<p>If we join chains of single nodes, we get the following compressed trie, which is the Suffix Tree for given text &#8220;banana\0&#8243;<br>
<a href="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/suffix-tree.png"><img class="aligncenter size-full wp-image-29276" title="suffix tree" src="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/suffix-tree.png" alt="" width="450" height="235"></a></p>
<p>Please note that above steps are just to manually create a Suffix Tree. We will be discussing actual algorithm and implementation in a separate post.</p>
<p><strong>How to search a pattern in the built suffix tree?</strong><br>
We have discussed above how to build a Suffix Tree which is needed as a preprocessing step in pattern searching. Following are abstract steps to search a pattern in the built Suffix Tree.<br>
<strong>1)</strong> Starting from the first character of the pattern and root of Suffix Tree, do following for every character.<br>
&#8230;..<strong>a)</strong> For the current character of pattern, if there is an edge from the current node of suffix tree, follow the edge.<br>
&#8230;..<strong>b)</strong> If there is no edge, print &#8220;pattern doesn&#8217;t exist in text&#8221; and return.<br>
<strong>2)</strong> If all characters of pattern have been processed, i.e., there is a path from root for characters of the given pattern, then print &#8220;Pattern found&#8221;.</p>
<p>Let us consider the example pattern as &#8220;nan&#8221; to see the searching process. Following diagram shows the path followed for searching &#8220;nan&#8221; or &#8220;nana&#8221;.</p>
<p><a href="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/suffixTreeSearch.png"><img class="aligncenter size-full wp-image-29317" title="suffixTreeSearch" src="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/suffixTreeSearch.png" alt="" width="450" height="235"></a></p>
<p><strong>How does this work?</strong><br>
Every pattern that is present in text (or we can say every substring of text) must be a prefix of one of all possible suffixes. The statement seems complicated, but it is a simple statement, we just need to take an example to check validity of it.</p>
<p><strong>Applications of Suffix Tree</strong><br>
Suffix tree can be used for a wide range of problems. Following are some famous problems where Suffix Trees provide optimal time complexity solution.<br>
1) Pattern Searching<br>
2) <a href="http://en.wikipedia.org/wiki/Longest_repeated_substring_problem" target="_blank">Finding the longest repeated substring</a><br>
3) <a href="http://en.wikipedia.org/wiki/Longest_common_substring_problem" target="_blank">Finding the longest common substring</a><br>
4) <a href="http://en.wikipedia.org/wiki/Longest_palindromic_substring" target="_blank">Finding the longest palindrome in a string</a></p>
<p>There are many more applications. See <a href="http://en.wikipedia.org/wiki/Suffix_tree#Functionality">this </a>for more details.</p>
<p>Ukkonen&#226;&#128;&#153;s Suffix Tree Construction is discussed in following articles:<br>
<a title="Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 1" href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank">Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 1</a><br>
<a title="Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 2" href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank">Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 2</a><br>
<a title="Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 3" href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank">Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 3</a><br>
<a title="Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 4" href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank">Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 4</a><br>
<a title="Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 5" href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank">Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 5</a><br>
<a title="Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 6" href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank">Ukkonen&#226;&#128;&#153;s Suffix Tree Construction &#226;&#128;&#147; Part 6</a></p>
<p><strong>References:</strong><br>
<a href="http://fbim.fh-regensburg.de/~saj39122/sal/skript/progr/pr45102/Tries.pdf" target="_blank">http://fbim.fh-regensburg.de/~saj39122/sal/skript/progr/pr45102/Tries.pdf</a><br>
<a href="http://www.cs.ucf.edu/~shzhang/Combio12/lec3.pdf" target="_blank">http://www.cs.ucf.edu/~shzhang/Combio12/lec3.pdf</a><br>
<a href="http://www.allisons.org/ll/AlgDS/Tree/Suffix/" target="_blank">http://www.allisons.org/ll/AlgDS/Tree/Suffix/</a></p>

&#160;
&#160;







&#160;
&#160;
&#160;
<p>Tags: <a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a>, <a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a>, <a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></p>






				<h3>Source:</h3><p><a href="http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/" rel="tag">http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/</a></p></div>
			</div></body>
