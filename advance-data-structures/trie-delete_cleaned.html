<body><div><div class="post" id="post">
							<div class="post-info">			
					<p class="post-title-info">
						</p><h2 class="post-title">Trie | (Delete)</h2>
								
					<p class="clear"></p>				  
				<div class="post-content" id="post-content">
					<p>In the <a href="http://www.geeksforgeeks.org/archives/13067" target="_blank">previous post</a> on <a href="http://en.wikipedia.org/wiki/Trie" target="_blank">trie</a> we have described how to insert and search a node in trie. Here is an algorithm how to delete a node from trie.<span id="more-15886"></span></p>
<p>During delete operation we delete the key in bottom up manner using recursion. The following are possible conditions when deleting key from trie,</p>
<ol>
<li>Key may not be there in trie. Delete operation should not modify trie.</li>
<li>Key present as unique key (no part of key contains another key (prefix), nor the key itself is prefix of another key in trie). Delete all the nodes.</li>
<li>Key is prefix key of another long key in trie. Unmark the leaf node.</li>
<li>Key present in trie, having atleast one other key as prefix key. Delete nodes from end of key until first leaf node of longest prefix key.</li>
</ol>
<p>The highlighted code presents algorithm to implement above conditions. (One may be in dilemma how a pointer passed to delete helper is reflecting changes from deleteHelper to deleteKey. Note that we are holding trie as an ADT in trie_t node, which is passed by reference or pointer).</p>
<pre class="brush: cpp; highlight: [134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171]; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])

// Alphabet size (# of symbols)

#define ALPHABET_SIZE (26)
#define INDEX(c) ((int)c - (int)'a')

#define FREE(p) \
    free(p);    \
    p = NULL;

// forward declration
typedef struct trie_node trie_node_t;

// trie node
struct trie_node
{
    int value; // non zero if leaf
    trie_node_t *children[ALPHABET_SIZE];
};

// trie ADT
typedef struct trie trie_t;

struct trie
{
    trie_node_t *root;
    int count;
};

trie_node_t *getNode(void)
{
    trie_node_t *pNode = NULL;

    pNode = (trie_node_t *)malloc(sizeof(trie_node_t));

    if( pNode )
    {
        int i;

        pNode-&gt;value   = 0;

        for(i = 0; i &lt; ALPHABET_SIZE; i++)
        {
            pNode-&gt;children[i] = NULL;
        }
    }

    return pNode;
}

void initialize(trie_t *pTrie)
{
    pTrie-&gt;root = getNode();
    pTrie-&gt;count = 0;
}

void insert(trie_t *pTrie, char key[])
{
    int level;
    int length = strlen(key);
    int index;
    trie_node_t *pCrawl;

    pTrie-&gt;count++;
    pCrawl = pTrie-&gt;root;

    for( level = 0; level &lt; length; level++ )
    {
        index = INDEX(key[level]);

        if( pCrawl-&gt;children[index] )
        {
            // Skip current node
            pCrawl = pCrawl-&gt;children[index];
        }
        else
        {
            // Add new node
            pCrawl-&gt;children[index] = getNode();
            pCrawl = pCrawl-&gt;children[index];
        }
    }

    // mark last node as leaf (non zero)
    pCrawl-&gt;value = pTrie-&gt;count;
}

int search(trie_t *pTrie, char key[])
{
    int level;
    int length = strlen(key);
    int index;
    trie_node_t *pCrawl;

    pCrawl = pTrie-&gt;root;

    for( level = 0; level &lt; length; level++ )
    {
        index = INDEX(key[level]);

        if( !pCrawl-&gt;children[index] )
        {
            return 0;
        }

        pCrawl = pCrawl-&gt;children[index];
    }

    return (0 != pCrawl &amp;&amp; pCrawl-&gt;value);
}

int leafNode(trie_node_t *pNode)
{
    return (pNode-&gt;value != 0);
}

int isItFreeNode(trie_node_t *pNode)
{
    int i;
    for(i = 0; i &lt; ALPHABET_SIZE; i++)
    {
        if( pNode-&gt;children[i] )
            return 0;
    }

    return 1;
}

bool deleteHelper(trie_node_t *pNode, char key[], int level, int len)
{
    if( pNode )
    {
        // Base case
        if( level == len )
        {
            if( pNode-&gt;value )
            {
                // Unmark leaf node
                pNode-&gt;value = 0;

                // If empty, node to be deleted
                if( isItFreeNode(pNode) )
                {
                    return true;
                }

                return false;
            }
        }
        else // Recursive case
        {
            int index = INDEX(key[level]);

            if( deleteHelper(pNode-&gt;children[index], key, level+1, len) )
            {
                // last node marked, delete it
                FREE(pNode-&gt;children[index]);

                // recursively climb up, and delete eligible nodes
                return ( !leafNode(pNode) &amp;&amp; isItFreeNode(pNode) );
            }
        }
    }

    return false;
}

void deleteKey(trie_t *pTrie, char key[])
{
    int len = strlen(key);

    if( len &gt; 0 )
    {
        deleteHelper(pTrie-&gt;root, key, 0, len);
    }
}

int main()
{
    char keys[][8] = {"she", "sells", "sea", "shore", "the", "by", "sheer"};
    trie_t trie;

    initialize(&amp;trie);

    for(int i = 0; i &lt; ARRAY_SIZE(keys); i++)
    {
        insert(&amp;trie, keys[i]);
    }

    deleteKey(&amp;trie, keys[0]);

    printf("%s %s\n", "she", search(&amp;trie, "she") ? "Present in trie" : "Not present in trie");

    return 0;
}
</pre>
<p>&#226;&#128;&#148;&#194;&#160;<strong><a href="http://www.linkedin.com/in/ramanawithu" target="_blank">Venki</a></strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
		
&#160;
&#160;







&#160;
&#160;
&#160;
<p>Tags: <a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></p> 






				<h3>Source:</h3><p><a href="http://www.geeksforgeeks.org/trie-delete/" rel="tag">http://www.geeksforgeeks.org/trie-delete/</a></p></div>		  
			</div> 					
						
        
			</div> 	

</div></body>