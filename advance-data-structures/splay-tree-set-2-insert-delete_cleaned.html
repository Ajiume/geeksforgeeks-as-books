<body><div><div class="post" id="post">
							<div class="post-info">			
					<p class="post-title-info">
						</p><h2 class="post-title">Splay Tree | Set 2 (Insert)</h2>
								
					<p class="clear"></p>				  
				<div class="post-content" id="post-content">
					<p>It is recommended to refer following post as prerequisite of this post.</p>
<p><a href="http://www.geeksforgeeks.org/splay-tree-set-1-insert/" target="_blank">Splay Tree | Set 1 (Search)</a><span id="more-125549"></span></p>
<p>As discussed in the <a href="http://www.geeksforgeeks.org/splay-tree-set-1-insert/" target="_blank">previous post</a>, Splay tree is a self-balancing data structure where the last accessed key is always at root. The insert operation is similar to Binary Search Tree insert with additional steps to make sure that the newly inserted key becomes the new root.</p>
<p>Following are different cases to insert a key k in splay tree.</p>
<p><strong>1)</strong> Root is NULL:  We simply allocate a new node and return it as root.</p>
<p><strong>2)</strong> <a href="http://www.geeksforgeeks.org/splay-tree-set-1-insert/" target="_blank">Splay </a>the given key k. If k is already present, then it becomes the new root.  If not present, then last accessed leaf node becomes the new root.</p>
<p><strong>3)</strong> If new root&#8217;s key is same as k, don&#8217;t do anything as k is already present.</p>
<p><strong>4)</strong> Else allocate memory for new node and compare root&#8217;s key with k.<br>
&#8230;&#8230;.<strong>4.a)</strong> If k is smaller than root&#8217;s key, make root as right child of new node, copy left child of root as left child of new node and make left child of root as NULL.<br>
&#8230;&#8230;.<strong>4.b)</strong> If k is greater than root&#8217;s key, make root as left child of new node, copy right child of root as right child of new node and make right child of root as NULL.</p>
<p><strong>5)</strong> Return new node as new root of tree.</p>
<p><strong>Example:</strong></p>
<pre> 
          100                  [20]                             25     
          /  \                   \                             /  \
        50   200                  50                          20   50 
       /          insert(25)     /  \        insert(25)           /  \  
      40          ======&gt;      30   100      ========&gt;           30  100    
     /          1. Splay(25)    \     \      2. insert 25         \    \
    30                          40    200                         40   200   
   /                                                          
 [20] </pre>
<pre class="brush: cpp; highlight: [106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140]; title: ; notranslate" title="">
// This code is adopted from http://algs4.cs.princeton.edu/33balanced/SplayBST.java.html
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// An AVL tree node
struct node
{
    int key;
    struct node *left, *right;
};

/* Helper function that allocates a new node with the given key and
    NULL left and right pointers. */
struct node* newNode(int key)
{
    struct node* node = (struct node*)malloc(sizeof(struct node));
    node-&gt;key   = key;
    node-&gt;left  = node-&gt;right  = NULL;
    return (node);
}

// A utility function to right rotate subtree rooted with y
// See the diagram given above.
struct node *rightRotate(struct node *x)
{
    struct node *y = x-&gt;left;
    x-&gt;left = y-&gt;right;
    y-&gt;right = x;
    return y;
}

// A utility function to left rotate subtree rooted with x
// See the diagram given above.
struct node *leftRotate(struct node *x)
{
    struct node *y = x-&gt;right;
    x-&gt;right = y-&gt;left;
    y-&gt;left = x;
    return y;
}

// This function brings the key at root if key is present in tree.
// If key is not present, then it brings the last accessed item at
// root.  This function modifies the tree and returns the new root
struct node *splay(struct node *root, int key)
{
    // Base cases: root is NULL or key is present at root
    if (root == NULL || root-&gt;key == key)
        return root;

    // Key lies in left subtree
    if (root-&gt;key &gt; key)
    {
        // Key is not in tree, we are done
        if (root-&gt;left == NULL) return root;

        // Zig-Zig (Left Left)
        if (root-&gt;left-&gt;key &gt; key)
        {
            // First recursively bring the key as root of left-left
            root-&gt;left-&gt;left = splay(root-&gt;left-&gt;left, key);

            // Do first rotation for root, second rotation is done after else
            root = rightRotate(root);
        }
        else if (root-&gt;left-&gt;key &lt; key) // Zig-Zag (Left Right)
        {
            // First recursively bring the key as root of left-right
            root-&gt;left-&gt;right = splay(root-&gt;left-&gt;right, key);

            // Do first rotation for root-&gt;left
            if (root-&gt;left-&gt;right != NULL)
                root-&gt;left = leftRotate(root-&gt;left);
        }

        // Do second rotation for root
        return (root-&gt;left == NULL)? root: rightRotate(root);
    }
    else // Key lies in right subtree
    {
        // Key is not in tree, we are done
        if (root-&gt;right == NULL) return root;

        // Zig-Zag (Right Left)
        if (root-&gt;right-&gt;key &gt; key)
        {
            // Bring the key as root of right-left
            root-&gt;right-&gt;left = splay(root-&gt;right-&gt;left, key);

            // Do first rotation for root-&gt;right
            if (root-&gt;right-&gt;left != NULL)
                root-&gt;right = rightRotate(root-&gt;right);
        }
        else if (root-&gt;right-&gt;key &lt; key)// Zag-Zag (Right Right)
        {
            // Bring the key as root of right-right and do first rotation
            root-&gt;right-&gt;right = splay(root-&gt;right-&gt;right, key);
            root = leftRotate(root);
        }

        // Do second rotation for root
        return (root-&gt;right == NULL)? root: leftRotate(root);
    }
}

// Function to insert a new key k in splay tree with given root
struct node *insert(struct node *root, int k)
{
    // Simple Case: If tree is empty
    if (root == NULL) return newNode(k);

    // Bring the closest leaf node to root
    root = splay(root, k);

    // If key is already present, then return
    if (root-&gt;key == k) return root;

    // Otherwise allocate memory for new node
    struct node *newnode  = newNode(k);

    // If root's key is greater, make root as right child
    // of newnode and copy the left child of root to newnode
    if (root-&gt;key &gt; k)
    {
        newnode-&gt;right = root;
        newnode-&gt;left = root-&gt;left;
        root-&gt;left = NULL;
    }

    // If root's key is smaller, make root as left child
    // of newnode and copy the right child of root to newnode
    else
    {
        newnode-&gt;left = root;
        newnode-&gt;right = root-&gt;right;
        root-&gt;right = NULL;
    }

    return newnode; // newnode becomes new root
}

// A utility function to print preorder traversal of the tree.
// The function also prints height of every node
void preOrder(struct node *root)
{
    if (root != NULL)
    {
        printf("%d ", root-&gt;key);
        preOrder(root-&gt;left);
        preOrder(root-&gt;right);
    }
}

/* Drier program to test above function*/
int main()
{
    struct node *root = newNode(100);
    root-&gt;left = newNode(50);
    root-&gt;right = newNode(200);
    root-&gt;left-&gt;left = newNode(40);
    root-&gt;left-&gt;left-&gt;left = newNode(30);
    root-&gt;left-&gt;left-&gt;left-&gt;left = newNode(20);
    root = insert(root, 25);
    printf("Preorder traversal of the modified Splay tree is \n");
    preOrder(root);
    return 0;
}
</pre>
<p>Output:
</p><pre>Preorder traversal of the modified Splay tree is
25 20 50 30 40 100 200</pre>
<p>This article is compiled by <strong>Abhay Rathi</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
		
&#160;
&#160;







&#160;
&#160;
&#160;
<p>Tags: <a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a>, <a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></p> 






				<h3>Source:</h3><p><a href="http://www.geeksforgeeks.org/splay-tree-set-2-insert-delete/" rel="tag">http://www.geeksforgeeks.org/splay-tree-set-2-insert-delete/</a></p></div>		  
			</div> 					
						
        
			</div> 	

</div></body>