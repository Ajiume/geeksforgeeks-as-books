<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Convert a BST to a Binary Tree such that sum of all greater keys is added to every key</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="convert-a-bst-to-a-binary-tree-such-that-sum-of-all-greater-keys-is-added-to-every-key" class="section level1 post-title">
<h1>Convert a BST to a Binary Tree such that sum of all greater keys is added to every key</h1>
<p></p>
<p>Given a Binary Search Tree (BST), convert it to a Binary Tree such that every key of the original BST is changed to key plus sum of all greater keys in BST. <span id="more-29039"></span></p>
<p>Examples:</p>
<pre><code>Input: Root of following BST
              5
            /   \
           2     13

Output: The given BST is converted to following Binary Tree
              18
            /   \
          20     13</code></pre>
<p>Source: <a href="http://www.geeksforgeeks.org/forum/topic/convert-a-bst">Convert a BST</a></p>
<p><strong>Solution:</strong> Do reverse Inoorder traversal. Keep track of the sum of nodes visited so far. Let this sum be <em>sum</em>. For every node currently being visited, first add the key of this node to <em>sum</em>, i.e. <em>sum</em> = <em>sum</em> + <em>node-&gt;key</em>. Then change the key of current node to <em>sum</em>, i.e., <em>node-&gt;key = sum</em>.<br /> When a BST is being traversed in reverse Inorder, for every key currently being visited, all keys that are already visited are all greater keys.</p>
<pre class="brush: cpp; highlight: [25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate" title=""><code>// Program to change a BST to Binary Tree such that key of a node becomes
// original key plus sum of all greater keys in BST
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A BST node has key, left child and right child */
struct node
{
    int key;
    struct node* left;
    struct node* right;
};

/* Helper function that allocates a new node with the given key and
   NULL left and right  pointers.*/
struct node* newNode(int key)
{
    struct node* node = (struct node*)malloc(sizeof(struct node));
    node-&gt;key = key;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    return (node);
}

// A recursive function that traverses the given BST in reverse inorder and
// for every key, adds all greater keys to it
void addGreaterUtil(struct node *root, int *sum_ptr)
{
    // Base Case
    if (root == NULL)
        return;

    // Recur for right subtree first so that sum of all greater
    // nodes is stored at sum_ptr
    addGreaterUtil(root-&gt;right, sum_ptr);

    // Update the value at sum_ptr
    *sum_ptr = *sum_ptr + root-&gt;key;

    // Update key of this node
    root-&gt;key = *sum_ptr;

    // Recur for left subtree so that the updated sum is added
    // to smaller nodes
    addGreaterUtil(root-&gt;left, sum_ptr);
}

// A wrapper over addGreaterUtil().  It initializes sum and calls
// addGreaterUtil() to recursivel upodate and use value of sum
void addGreater(struct node *root)
{
    int sum = 0;
    addGreaterUtil(root, &amp;sum);
}

// A utility function to print inorder traversal of Binary Tree
void printInorder(struct node* node)
{
    if (node == NULL)
        return;
    printInorder(node-&gt;left);
    printf(&quot;%d &quot;, node-&gt;key);
    printInorder(node-&gt;right);
}

// Driver program to test above function
int main()
{
    /* Create following BST
              5
            /   \
           2     13  */
    node *root = newNode(5);
    root-&gt;left = newNode(2);
    root-&gt;right = newNode(13);

    printf(&quot; Inorder traversal of the given tree\n&quot;);
    printInorder(root);

    addGreater(root);

    printf(&quot;\n Inorder traversal of the modified tree\n&quot;);
    printInorder(root);

    return 0;
}</code></pre>
<p>Output:</p>
<pre><code> Inorder traversal of the given tree
2 5 13
 Inorder traversal of the modified tree
20 18 13</code></pre>
<p>Time Complexity: O(n) where n is the number of nodes in given Binary Search Tree.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p>   </p>
<p>Tags: <a href="http://www.geeksforgeeks.org/tag/amazon/">Amazon</a>, <a href="http://www.geeksforgeeks.org/tag/bst/">BST</a></p>
<div id="source-4" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/convert-bst-to-a-binary-tree/" class="uri">http://www.geeksforgeeks.org/convert-bst-to-a-binary-tree/</a></p>
<p></p>
</div>
</div>
</body>
</html>

